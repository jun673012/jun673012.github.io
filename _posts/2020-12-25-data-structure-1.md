---
layout: post
title: Data Structure
subtitle: C언어로 쉽게 풀어쓴 자료구조
share-img: /assets/img/path.jpg
tags: [books, C, DataStructure]
---

### 1.   자료구조, 알고리즘

자료구조는 프로그램에서 자료들을 정리하여 보관하는 여러가지 구조

알고리즘은 문제 해결을 위한 단계적인 철자

알고리즘 만족조건

> 입력: 0개 이상의 입력이 존재

> 출력: 1개 이상의 출력이 존재

> 명백성: 각 명령어의 의미는 모호하지않고 명확해야함

> 유한성: 한정된 수의 단계후에는 반드시 종료되야함

> 유효성: 각 명령어들은 종이나 연필, 컴퓨터로 실행 가능한 연산이여야함

프로그램 (자료처리) = 자료구조(저장) + 알고리즘(처리절차)

효율적 조직화를 위해 사용할 자료구조 결정하면 응용에 적합한 알맞은 알고리즘 결정

### 2.   추상 자료형

> 자료형(data type): 데이터의 종류, 자료형

자료형 작성시 데이터 종류가 결정되면 데이터에 관련된 연산도 달라지기에 실행 가능한 연산에    신경써야함

복잡한 자료형 구현시 연산 → 연산자x 함수로 작성됨

> 추상 자료형(ADT: abstract data type): 추상적, 수학적으로 자료형을 정의                                                                           실제적인 구현으로부터 분리되어 정의된 자료형

1. 사용자들은 ADT가 제공하는 연산만을 사용할 수 있다.
2. 사용자들은 ADT가 제공하는 연산들을 사용하는 방법을 알아야 있다.
3. 사용자들은 ADT 내부의 데이터를 접근할 수 없다.
4. 사용자들은 ADT가 어떻게 구현되는지 모르더라도 ADT를 사용할 수 있다.
5. 만약 다른 사람이 ADT의 구현을 변경하더라고 인터페이스가 변경되지 않으면 사용자들은 여전히 ADT를 같은 방식으로 사용할 수 있다.

- 소프트웨어 개발과 유지보수에 있어서 중요한 이슈는 소프트웨어 복잡성 관리였고 이것을 대처하기 위해 새로운 아이디어들이 등장했고 유력한 주제는 추상화와 관련된 도구들의 개발이었음
- 추상화란 시스템의 간략화된 기술 또는 명세로써 핵심적인 구조나 동작에만 집중하는것
- 좋은추상화란 사용자에게 중요한 정보는 강조되고 중요하지않은 구현 세부 상항은 제거되는것
- 이를 위해 정보은닉기법(information hiding)이 개발되었고 추상자료형(ADT)의 개념으로 발전됨

- 정보은닉기법
    - 추상자료형이 구현될때 구현세부사항은 외부에 알리지 않고 외부와의 인터페이스만을 공개함
    - 사용자는 구현세부사항이 아닌 인터페이스만 사용하기 떄문에 추상 자료형의  구현방법은 언제든지 안전하게 변경될 수 있음
    - 인터페이스만 정확하게 지켜진다면 추상 자료형이 여러 가지 방법으로 구현될 수 있음을 뜻함
    - 즉 프로그램을 변경가능성있는 구현의 세부사항으로 보호하는것이고 구현으로부터의 명세의 분리가 추상자료형의 중심 아이디어

### 3.   알고리즘의 성능 분석

프로그램의 효율성 중요

최근 상용 프로그램의 규모가 이번에 비해 엄청나게 커지고 있기 때문

사용자들이 빠른 프로그램을 선호하기 때문

- 수행시간 측정방법

가장 확실한 방법은 알고리즘을 프로그래밍 언어로 작성하여 컴퓨터상에서 실행시킨 다음, 수행시간을 측정하는 것

1. 호출 프로세스에 의하여 사용된 CPU 시간을 계산하는 함수 이용

```c
clock()
```

**clock()** 함수는 호출되었을 때의 시스템 시간을 CLOCK_PER_SEC 단위로 반환함

따라서 수행시간을 알기위해서 알고리즘을 시작하기전에 **clock()** 함수를 호출하여 변수에 기록하고,알고리즘이 끝나면 다시 **clock()** 함수를 호출하여 다른 변수에 기록한 다음, 초단위의 시간을 측정하기 위해서 (종료변수 - 시작변수) 값을 CLOCK_PER_SEC으로 나누면 됨

 2.   초 단위로 측정된 시간을 반환하는 함수 이용

```c
time()
```

time(NULL) 형태로 호출하면 현재 시간이 넘어옴

프로그램의 시작과 종료 시점에서 time(NULL) 함수를 호출한 후에, 두 가지 시간을

```c
difftime()
```

으로 보내면 차이가 초단위로 반환됨

- 문제점
    - 이 방법을 사용하려면 알고리즘을 구현하고 테스트하는 과정이 필요함
    - 알고리즘이 단순하다면 쉽게 구현하면 되지만 복잡하다면 구현해야 한다는 점이 큰부담
    - 이 방법으로 2개의 알고리즘을 비교하려면 반드시 같은 하드웨어, 소프트웨어를 사용해서 수행시간을 측정
    - 실험에 사용했던 데이터가 아닌 데이터에 대해서는 전혀 다른 결과가 나올 수 있음

- 알고리즘의 복잡도 분석방법
    - 위와 같은 문제점 때문에 구현하지 않고도 알고리즘의 효율성을 따져보는 기법이 개발됨
    - 직접 수행하지 않고도 각 방법의 결과를 예측할 수 있는 방법
    - 이것이 알고리즘 복잡도 분석(complexity analysis)
    - 알고리즘 복잡도 분석은 구현하지 않고도 모든 입력을 고려하는 방법이고 실행 하드웨어, 소프트웨어 환경과는 관계없이 알고리즘의 효율성을 평가 할 수 있음

- 시간 복잡도 함수
    - 알고리즘 분석에서 좋다는 의미를 분명히 해야함

        어떤 기준으로 좋은지 - 예) 시간인지 거리인지 속도인지

- 알고리즘 분석에서 2가지 측면 고려할 수 있음
    - 시간 복잡도(time complexity)   - 알고리즘의 수행시간 분석
    - 공간 복잡도(space complexity) - 알고리즘이 사용하는 기억공간 분석

- 보통 알고리즘의 복잡도를 말할 때는 시간 복잡도를 말함

    **왜?** 알고리즘이 차지하는 공간보다는 수행시간에 더 관심이 있기 때문에

- 시간 복잡도는 알고리즘의 절대적인 수행 시간을 나타내는 것이 아니라 알고리즘을 이루고 있는 연산들의 수행 횟수를 숫자로 표시함
- 알고리즘의 복잡도를 분석할 때는 연산의 수행횟수를 사용함

- 다른 두개의 알고리즘이 동일한 조건에서 , 똑같은 일을 하는데 하나는 20번의 연산을 수행했고 다른 하나는 100번의 연산을 수행했다면 첫번째 알고리즘이 연산의 수가 적으므로 더 효율적인 알고리즘이라 할 수 있음
- 하지만 수행횟수는 값이 변하지 않는 상수가 아니고 입력의 개수에 따라 변함
- 따라서 연산의 수행횟수는 입력의 개수에 대한 함수가 되고, 연산의 수를 입력의 개수 n의 함수로 나타낸 것을 시간 복잡도 함수라 하고

> T(n)

이라고 표기함

- 빅오 표기법

> 두개의 함수 f(n)과 g(n)이 주어졌을 때, 모든 n > n。에 대하여 ㅣf(n)ㅣ ≤ ㅣg(n) 을 만족하는 2개의 상수 c 와 n。가 존재하면 f(n) = O(g(n)) 이다.

입력의 개수와 시간 복잡도 함수의 관계는 상당히 복잡할 수 있음

하지만 자료의 개수가 많은 경우 차수가 가장 큰 항이 가장 영향을 크게 미치고 다른 항들은 상대적으로 무시될 수 있음

빅오 표기법을 사용하면 시간 복잡도 함수의 증가에 별로 기여하지 못하는 항을 생략함으로써 시간복잡도를 간단히 표시할 수 있음

- 빅오 표기법 얻는 간단한 방법
    - 기본연산의 횟수가 다항식으로 표현되었을때, 다항식의 최고차항만 남기고 다른 항들과 상수항을 버림
    - 최고차수의 계수도 버리고 최고차항만 사용함
        - log n 은 없애면 안됨 → log n 도 차수를 가지고 있기 때문

- 빅오 표기법 순서 (속도순)
    - O(1) 상수형
    - O(log n) 로그형
    - O(n) 선형
    - O(n log n) 선형로그형
    - O(n²) 2차형
    - O(n³) 3차형
    - O(2ⁿ) 지수형
    - O(n!) 팩토리얼형

빅오 표기법은 상한을 표기한 것이므로 여러개가 존재할 수 있음

이 문제점을 보완하기 위해 다른 표기법이 있음

- 빅오 표기법 이외의 표기법
    - 빅오메가 표기법

    어떤 함수의 하한을 표기하는 방법

    > 두개의 함수 f(n)과 g(n)이 주어졌을 때, 모든 n > n。에 대하여 ㅣg(n)ㅣ ≤ ㅣf(n)ㅣ 을 만족하는 2개의 상수 c 와 n。가 존재하면 f(n) = Ω(g(n)) 이다.

    - 빅세타 표기법

    동일한 함수로 상한과 하한을 만들 수 있는 경우

    > 두개의 함수 f(n)과 g(n)이 주어졌을 때, 모든 n > n。에 대하여 c₁ ≤ ㅣf(n)ㅣ ≤ c₂ㅣg(n)ㅣ 을 만족하는 3개의 상수 c₁, c₂ 와 n。가 존재하면 f(n) = θ(g(n)) 이다.

- 최선, 평균, 최악의 경우

    알고리즘의 효율성은 자료집합에 따라 3가지 경우로 나누어서 평가할 수 있음

    1. 최악 (Worst Case) - 알고리즘의 수행시간이 가장 오래 걸리는 경우
    2. 최선 (Best Case) - 수행시간이 가장 적은 경우
    3. 평균 (Average Case) - 모든 입력과 각 입력이 발생하는 확률을 고려하여 수행시간이 평균적인 경우
