---
layout: post
title: Data Structure 4
subtitle: C언어로 쉽게 풀어쓴 자료구조
tags: [C, DataStructure]
---

**스택**


    ### 1.   스택이란


    상자를 쌓는것처럼 밑에서부터 위로 쌓여지고 먼저 들어온 상자가 먼저 나가는 후입선출(LIFO: Last in First Out) 형태

    입출력은 맨 위에서만 일어나고 스택의 중간에서는 데이터 삭제 못함

    스택의 입출력이 이루어지는 부분을 스택 상단, 바닥부분을 스택 하단, 저장 되는것을 요소라 하고 요소가 하나도 없으면 공백 스택이라 함

    자료의 출력순서가 입력순서의 역순일떄 사용하기 매우 좋음

    스택의 두 가지 기본 연산

    - push 연산: 삽입 연산
    - pop 연산: 삭제 연산

    그외
    
    - is_empty, is_full 연산: 스택이 공백상태인지 포화상태인지 검사하는 함수
    - create 연산: 스택을 생성하는 함수
    - peek 연산: 요소를 스택에서 삭제하지 않고 보기만하는 연산 (pop 연산은 요소를 스택에서 완전히 삭제하며 가져옴)




**큐**


    ### 1.   큐 추상 데이터 타입


    큐(queue)는 먼저 들어온 데이터가 먼저 나가는 구조인 선입선출(FIFO: First In First Out).

    스택과 연산들이 유사함

    가장 중요한 연산

    - enqueue연산: 큐에 요소를 추가하는 연산, 큐의 맨 뒤에 새로운 요소를 추가함
    - dequeue연산: 큐의 맨 앞에 있는 요소를 꺼내서 외부로 반환

    스택에 비해 큐는 두개의 변수 사용함

    삽입과 관련된 변수를 rear, 삭제와 관련된 변수를 front이라 함


    - 선형큐

    front와 rear의 초기값은 -1임

    데이터가 증가하면 rear를 하나 증가하고 그 위치에 데이터가 저장됨

    삭제할 때도 front를 하나 증가하고 front가 가리키는 위치에 있는 데이터를 삭제함


    - 원형큐

    선형큐는 front와 rear의 값이 계속 증가만 하기 때문에 언젠가는 배열의 끝에 도달하게 되고 배열 앞부분이 비어 있더라고 사용하지 못한다는 문제점이 있음

    따라서 주기적으로 모든 요소들을 왼쪽으로 이동시켜야 하고, 배열을 선형이 아닌 처음과 끝이 연결되어있는 원형으로 생각하면 쉽게 해결됨

    원형큐의 초기값은 -1이 아닌 0임

    front는 항상 큐의 첫 번째 요소의 하나 앞을, rear는 마지막 요소를 가리킴

    처음에 front, rear는 모두 0이고 삽입 시에 rear가 먼저 증가된 후, 증가된 위치에 새로운 데이터 삽입됨

    삭제 시에도 front가 먼저 증가된 다음, 증다된 위치에서 데이터를 삭제함

    원형큐에서는 포화 상태와 공백 상태를 구별하기 위해 하나의 자리를 항상 비워둠

    한 자리를 비워두지 않는다면 포화 상태와 공백 상태를 구분할 수 없음

    요소들의 개수를 저장하고 았는 추가적인 변수를 사용할 수 있다면 비워두지 않아도 됨


    ### 2.   버퍼


    큐는 서로 다른 속도로 실행되는 두 프로세스 간의 상호 작용을 조화시키는 버퍼 역할을 담당함

    예) CPU와 프린터 사지의 프린팅 버퍼, CPU와 키보드 사이의 키보드 버퍼


    ### 3.   덱


    덱(deque)은 double-ended queue의 줄임말로 큐의 전단(front)과 후단(rear)에서 모두 삽입과 삭제가 가능한 큐를 의미함

    중간에 삽입하거나 삭제하는 것은 허용하지않음

    - 덱의 추상 자료형


    연산


    create() 덱 생성

    init(dq) 덱초기화

    is_empty(dq) 덱이 공백 상태인지 검사

    is_full(dq) 덱이 포화 상태인지 검사

    add_front(dq) 덱의 앞에 요소 추가

    add_rear(dq) 덱의 뒤에 요소 추가

    delete_front(dq) 덱의 앞에 있는 요소를 반환한 다음 삭제

    delete_rear(dq) 덱의 뒤에 있는 요소를 반환한 다음 삭제

    get_front(dq) 덱의 앞에서 삭제하지 않고 앞에 있는 요소를 반환

    get_rear(dq) 덱의 뒤에서 삭제하지 않고 앞에 있는 요소를 반환
    
    
    
    
